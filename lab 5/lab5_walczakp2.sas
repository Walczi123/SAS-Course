/*[ItSAS] Lab5 Patryk Walczak*/

libname lab5 "C:\Users\patry\Downloads\lab5";

/* Ex 5.1 */
/*5.1 We are given a data set a with a grouping variable x and an additional numeric variable u.*/
/*Find the largest (absolute) difference of consecutive values of y in every group formed by x.*/
data lab5.ex1;
 set lab5.a;
 by x;

 retain max_difference;
 upper_value = lag(u);

 if first.x then max_difference = 0;
 else if abs(upper_value-u) > max_difference then max_difference = abs(upper_value-u);
 if last.x then output;

 keep x max_difference;
run;

/* Ex 5.2 */
/*5.2 We are given a data set b with a grouping variable x and numeric variables y1,...,y10. */
/*For every value of x find ten largest values of the variables y1,...,y10.*/
data lab5.ex2;
 set lab5.b;
 by x;
 array y(*) y1-y10;
 array  max(10)max_y1-max_y10;
 retain max_y1-max_y10;

 if first.x then do i=1 to 10;
  max(i)=.;
 end;

 do i=1 to 10;
  do j=1 to 10;
   if y(i)>max(j) then do;
	if j<10 then do k=9 to j by -1;
	 max(k+1)=max(k);
	end;	
	max(j)=y(i);
	leave;
   end;
  end;
 end;

 if last.x then output;
 keep x max:;
run;

/* Ex 5.3 */
/*We are given a data set c with a grouping variable x and numeric variables y1,...,y10. */
/*Each group generated by x has 5 rows. Replace the missing values in every group */
/*by the arithmetic mean of the non-missing y1,...,y10 values from the group.*/
data lab5.ex3;
 set lab5.c;
 by x;

 array y(*) y1-y10;
 array new_y(10);
 array  _y(5,10)_temporary_;
 array non_empty(10)_temporary_;
 array my_sum(10)_temporary_;
 array my_mean(10) _temporary_;
 retain row;

 if first.x then do;
  do i=1 to 10;
   do j=1 to 5;
	_y(j,i)=.;
   end;
  my_sum(i)=0;
  non_empty(i)=0;
  end;
 row=0;
 end;
 
 row+1; 
 do i=1 to 10;
  _y(row,i)=y(i);
  if y(i) ne . then do;
   non_empty(i)+1;
   my_sum(i)+y(i);
  end;
 end;

 if last.x then do;
  do i=1 to 10;
   my_mean(i)=my_sum(i)/non_empty(i);
   do j=1 to 5;
    if _y(j,i) = . then _y(j,i)=my_mean(i);
   end;
  end;

  do j=1 to 5;
   do i=1 to 10;
    new_y(i)=_y(j,i);
   end;
   output;
  end;
 end;
 keep x new_y1-new_y10;
run;

/* Ex 5.4 */
/* Consider a data set values with a single character variable, with the values of the form: 
”value 1, value 2, value 3, ..., value n”, where value is a number, and n diﬀers from row to row. 
Create a data set with a single numeric variable, storing split values from values. 
Each of the split values should make a separate row in the new data set. */

/*countw(x,". ")*/
/*scan(x,i,", ")*/
/*input*/

data lab5.ex4;
 set lab5.values;
 k=countw(x,", ");
 do i=1 to k;
  value=scan(x,i,", ");
  output;
 end;
 keep value;
run;

/* Ex 5.5 */

/* Consider a system generating alerts for clients at some moments of time. 
There is a table ALERT CLIENT with three columns: alert id, client id and alert time (alert generation time). 
• Generate a report (create a data set) that lists all the alerts for which 
the associated client had a previous alert more recently than two years ago. 
• Do the same but without sorting the table (it may be very big). 
You can now assume that: 
– the values in alert id are not duplicated, 
– they are strictly decreasing, 
– the values in alert date never increase.
For the attached data set: 
• alert id = 5028 should not be reported 
(as the previous alert date for client id = 1001 is 02/15/2018, which is earlier than two years from 03/02/2020), 
• alert id = 4982 should be reported 
(as the previous alert date for client id = 1014 is 05/30/2017, which is more recent than two years from 04/26/2019). */

proc sort data=lab5.alert_client out=lab5.alert_clients;
 by client_id descending alert_date;
run;

data lab5.ex5a;
 set lab5.alert_clients;
 by client_id;

 retain rep;
 
 lad = lag(alert_date);
 
 if first.client_id then rep=0;
 else do;
  if lad-alert_date<2*365 then rep=1;
 end;
 
 if last.client_id and rep=1 then output;
 keep client_id;
run;

data lab5.ex5b;
 set lab5.alert_clients;
 by client_id;
 
 array lastdate(500) _temporary_;
 array outputed(500) _temporary_;
 
 if lastdate(client_id-1000) eq . then lastdate(client_id-1000)=alert_date;
 else
  if lastdate(client_id-1000)-alert_date<2*365 and outputed(client_id-1000) eq . then do;
   output;
   outputed(client_id-1000)=1;
  end;
  else outputed(client_id-1000)=alert_date;
 
run;

/* Ex 5.6 */
/*  Data set d contains variable year and variables y1,..., y12 with results for each month. 
Create a dataset, which contains variable date being the ﬁrst day in a given month (use date9. format) 
and variable y being the value for a respective month (see data set dtrans). */

data lab5.ex6;
 format date date9.;
 set lab5.d;
 
 array arr(12) y1-y12;
 do i=1 to 12;
  date = mdy(i,1,year);
  y = arr(i);
  output; 
end;
keep date y;
run;

/* Ex 5.7 */
/*  Assume you are given the data set dtrans. Transform it into a data set of the same structure as d. */

data lab5.ex7;
 set lab5.dtrans; 

 year = year(date);

 array arr(12) y1-y12;
 retain y1-y12;

 m = month(date);
 arr(m)= y;
 if m eq 12 then output;

 keep year y1-y12;
run;
